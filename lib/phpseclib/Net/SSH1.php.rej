--- lib/phpseclib/Net/SSH1.php
+++ lib/phpseclib/Net/SSH1.php
@@ -1,230 +1,263 @@
 <?php
+/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of SSHv1.
  *
- * PHP version 5
+ * PHP versions 4 and 5
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include 'vendor/autoload.php';
+ *    include('Net/SSH1.php');
  *
- *    $ssh = new \phpseclib\Net\SSH1('www.domain.tld');
+ *    $ssh = new Net_SSH1('www.domain.tld');
  *    if (!$ssh->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
  *
- *    echo $ssh->exec('ls -la');
+ *    while (true) {
+ *        echo $ssh->interactiveRead();
+ *
+ *        $read = array(STDIN);
+ *        $write = $except = NULL;
+ *        if (stream_select($read, $write, $except, 0)) {
+ *            $ssh->interactiveWrite(fread(STDIN, 1));
+ *        }
+ *    }
  * ?>
  * </code>
  *
  * Here's another short example:
  * <code>
  * <?php
- *    include 'vendor/autoload.php';
+ *    include('Net/SSH1.php');
  *
- *    $ssh = new \phpseclib\Net\SSH1('www.domain.tld');
+ *    $ssh = new Net_SSH1('www.domain.tld');
  *    if (!$ssh->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
  *
- *    echo $ssh->read('username@username:~$');
- *    $ssh->write("ls -la\n");
- *    echo $ssh->read('username@username:~$');
+ *    echo $ssh->exec('ls -la');
  * ?>
  * </code>
  *
- * More information on the SSHv1 specification can be found by reading
+ * More information on the SSHv1 specification can be found by reading 
  * {@link http://www.snailbook.com/docs/protocol-1.5.txt protocol-1.5.txt}.
  *
- * @category  Net
- * @package   SSH1
- * @author    Jim Wigginton <terrafrost@php.net>
- * @copyright 2007 Jim Wigginton
- * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
- * @link      http://phpseclib.sourceforge.net
+ * LICENSE: This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA  02111-1307  USA
+ *
+ * @category   Net
+ * @package    Net_SSH1
+ * @author     Jim Wigginton <terrafrost@php.net>
+ * @copyright  MMVII Jim Wigginton
+ * @license    http://www.gnu.org/licenses/lgpl.txt
+ * @version    $Id: SSH1.php,v 1.15 2010/03/22 22:01:38 terrafrost Exp $
+ * @link       http://phpseclib.sourceforge.net
+ */
+
+/**
+ * Include Math_BigInteger
+ *
+ * Used to do RSA encryption.
+ */
+require_once('phpseclib/Math/BigInteger.php');
+
+/**
+ * Include Crypt_Null
  */
+//require_once('Crypt/Null.php');
 
-namespace phpseclib\Net;
+/**
+ * Include Crypt_DES
+ */
+require_once('phpseclib/Crypt/DES.php');
 
-use phpseclib\Crypt\DES;
-use phpseclib\Crypt\Random;
-use phpseclib\Crypt\TripleDES;
-use phpseclib\Math\BigInteger;
+/**
+ * Include Crypt_TripleDES
+ */
+require_once('phpseclib/Crypt/TripleDES.php');
 
 /**
- * Pure-PHP implementation of SSHv1.
+ * Include Crypt_RC4
+ */
+require_once('phpseclib/Crypt/RC4.php');
+
+/**
+ * Include Crypt_Random
+ */
+require_once('phpseclib/Crypt/Random.php');
+
+/**#@+
+ * Protocol Flags
+ *
+ * @access private
+ */
+define('NET_SSH1_MSG_DISCONNECT',          1);
+define('NET_SSH1_SMSG_PUBLIC_KEY',         2);
+define('NET_SSH1_CMSG_SESSION_KEY',        3);
+define('NET_SSH1_CMSG_USER',               4);
+define('NET_SSH1_CMSG_AUTH_PASSWORD',      9);
+define('NET_SSH1_CMSG_REQUEST_PTY',       10);
+define('NET_SSH1_CMSG_EXEC_SHELL',        12);
+define('NET_SSH1_CMSG_EXEC_CMD',          13);
+define('NET_SSH1_SMSG_SUCCESS',           14);
+define('NET_SSH1_SMSG_FAILURE',           15);
+define('NET_SSH1_CMSG_STDIN_DATA',        16);
+define('NET_SSH1_SMSG_STDOUT_DATA',       17);
+define('NET_SSH1_SMSG_STDERR_DATA',       18);
+define('NET_SSH1_SMSG_EXITSTATUS',        20);
+define('NET_SSH1_CMSG_EXIT_CONFIRMATION', 33);
+/**#@-*/
+
+/**#@+
+ * Encryption Methods
+ *
+ * @see Net_SSH1::getSupportedCiphers()
+ * @access public
+ */
+/**
+ * No encryption
+ *
+ * Not supported.
+ */
+define('NET_SSH1_CIPHER_NONE',       0);
+/**
+ * IDEA in CFB mode
+ *
+ * Not supported.
+ */
+define('NET_SSH1_CIPHER_IDEA',       1);
+/**
+ * DES in CBC mode
+ */
+define('NET_SSH1_CIPHER_DES',        2);
+/**
+ * Triple-DES in CBC mode
+ *
+ * All implementations are required to support this
+ */
+define('NET_SSH1_CIPHER_3DES',       3);
+/**
+ * TRI's Simple Stream encryption CBC
+ *
+ * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, does define it (see cipher.h),
+ * although it doesn't use it (see cipher.c)
+ */
+define('NET_SSH1_CIPHER_BROKEN_TSS', 4);
+/**
+ * RC4
+ *
+ * Not supported.
+ *
+ * @internal According to the SSH1 specs:
+ *
+ *        "The first 16 bytes of the session key are used as the key for
+ *         the server to client direction.  The remaining 16 bytes are used
+ *         as the key for the client to server direction.  This gives
+ *         independent 128-bit keys for each direction."
+ *
+ *     This library currently only supports encryption when the same key is being used for both directions.  This is
+ *     because there's only one $crypto object.  Two could be added ($encrypt and $decrypt, perhaps).
+ */
+define('NET_SSH1_CIPHER_RC4',        5);
+/**
+ * Blowfish
  *
- * @package SSH1
- * @author  Jim Wigginton <terrafrost@php.net>
- * @access  public
+ * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, defines it (see cipher.h) and
+ * uses it (see cipher.c)
  */
-class SSH1
-{
-    /**#@+
-     * Encryption Methods
-     *
-     * @see \phpseclib\Net\SSH1::getSupportedCiphers()
-     * @access public
-     */
-    /**
-     * No encryption
-     *
-     * Not supported.
-     */
-    const CIPHER_NONE = 0;
-    /**
-     * IDEA in CFB mode
-     *
-     * Not supported.
-     */
-    const CIPHER_IDEA = 1;
-    /**
-     * DES in CBC mode
-     */
-    const CIPHER_DES = 2;
-    /**
-     * Triple-DES in CBC mode
-     *
-     * All implementations are required to support this
-     */
-    const CIPHER_3DES = 3;
-    /**
-     * TRI's Simple Stream encryption CBC
-     *
-     * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, does define it (see cipher.h),
-     * although it doesn't use it (see cipher.c)
-     */
-    const CIPHER_BROKEN_TSS = 4;
-    /**
-     * RC4
-     *
-     * Not supported.
-     *
-     * @internal According to the SSH1 specs:
-     *
-     *        "The first 16 bytes of the session key are used as the key for
-     *         the server to client direction.  The remaining 16 bytes are used
-     *         as the key for the client to server direction.  This gives
-     *         independent 128-bit keys for each direction."
-     *
-     *     This library currently only supports encryption when the same key is being used for both directions.  This is
-     *     because there's only one $crypto object.  Two could be added ($encrypt and $decrypt, perhaps).
-     */
-    const CIPHER_RC4 = 5;
-    /**
-     * Blowfish
-     *
-     * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, defines it (see cipher.h) and
-     * uses it (see cipher.c)
-     */
-    const CIPHER_BLOWFISH = 6;
-    /**#@-*/
+define('NET_SSH1_CIPHER_BLOWFISH',   6);
+/**#@-*/
 
-    /**#@+
-     * Authentication Methods
-     *
-     * @see \phpseclib\Net\SSH1::getSupportedAuthentications()
-     * @access public
-    */
-    /**
-     * .rhosts or /etc/hosts.equiv
-     */
-    const AUTH_RHOSTS = 1;
-    /**
-     * pure RSA authentication
-     */
-    const AUTH_RSA = 2;
-    /**
-     * password authentication
-     *
-     * This is the only method that is supported by this library.
-     */
-    const AUTH_PASSWORD = 3;
-    /**
-     * .rhosts with RSA host authentication
-     */
-    const AUTH_RHOSTS_RSA = 4;
-    /**#@-*/
+/**#@+
+ * Authentication Methods
+ *
+ * @see Net_SSH1::getSupportedAuthentications()
+ * @access public
+ */
+/**
+ * .rhosts or /etc/hosts.equiv
+ */
+define('NET_SSH1_AUTH_RHOSTS',     1);
+/**
+ * pure RSA authentication
+ */
+define('NET_SSH1_AUTH_RSA',        2);
+/**
+ * password authentication
+ *
+ * This is the only method that is supported by this library.
+ */
+define('NET_SSH1_AUTH_PASSWORD',   3);
+/**
+ * .rhosts with RSA host authentication
+ */
+define('NET_SSH1_AUTH_RHOSTS_RSA', 4);
+/**#@-*/
 
-    /**#@+
-     * Terminal Modes
-     *
-     * @link http://3sp.com/content/developer/maverick-net/docs/Maverick.SSH.PseudoTerminalModesMembers.html
-     * @access private
-    */
-    const TTY_OP_END = 0;
-    /**#@-*/
+/**#@+
+ * Terminal Modes
+ *
+ * @link http://3sp.com/content/developer/maverick-net/docs/Maverick.SSH.PseudoTerminalModesMembers.html
+ * @access private
+ */
+define('NET_SSH1_TTY_OP_END',  0);
+/**#@-*/
 
-    /**
-     * The Response Type
-     *
-     * @see \phpseclib\Net\SSH1::_get_binary_packet()
-     * @access private
-     */
-    const RESPONSE_TYPE = 1;
+/**
+ * The Response Type
+ *
+ * @see Net_SSH1::_get_binary_packet()
+ * @access private
+ */
+define('NET_SSH1_RESPONSE_TYPE', 1);
 
-    /**
-     * The Response Data
-     *
-     * @see \phpseclib\Net\SSH1::_get_binary_packet()
-     * @access private
-     */
-    const RESPONSE_DATA = 2;
+/**
+ * The Response Data
+ *
+ * @see Net_SSH1::_get_binary_packet()
+ * @access private
+ */
+define('NET_SSH1_RESPONSE_DATA', 2);
 
-    /**#@+
-     * Execution Bitmap Masks
-     *
-     * @see \phpseclib\Net\SSH1::bitmap
-     * @access private
-    */
-    const MASK_CONSTRUCTOR = 0x00000001;
-    const MASK_CONNECTED   = 0x00000002;
-    const MASK_LOGIN       = 0x00000004;
-    const MASK_SHELL       = 0x00000008;
-    /**#@-*/
-
-    /**#@+
-     * @access public
-     * @see \phpseclib\Net\SSH1::getLog()
-    */
-    /**
-     * Returns the message numbers
-     */
-    const LOG_SIMPLE = 1;
-    /**
-     * Returns the message content
-     */
-    const LOG_COMPLEX = 2;
-    /**
-     * Outputs the content real-time
-     */
-    const LOG_REALTIME = 3;
-    /**
-     * Dumps the content real-time to a file
-     */
-    const LOG_REALTIME_FILE = 4;
-    /**#@-*/
-
-    /**#@+
-     * @access public
-     * @see \phpseclib\Net\SSH1::read()
-    */
-    /**
-     * Returns when a string matching $expect exactly is found
-     */
-    const READ_SIMPLE = 1;
-    /**
-     * Returns when a string matching the regular expression $expect is found
-     */
-    const READ_REGEX = 2;
-    /**#@-*/
+/**#@+
+ * Execution Bitmap Masks
+ *
+ * @see Net_SSH1::bitmap
+ * @access private
+ */
+define('NET_SSH1_MASK_CONSTRUCTOR', 0x00000001);
+define('NET_SSH1_MASK_LOGIN',       0x00000002);
+define('NET_SSH1_MASK_SHELL',       0x00000004);
+/**#@-*/
 
+/**
+ * Pure-PHP implementation of SSHv1.
+ *
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @version 0.1.0
+ * @access  public
+ * @package Net_SSH1
+ */
+class Net_SSH1 {
     /**
      * The SSH identifier
      *
-     * @var string
+     * @var String
      * @access private
      */
     var $identifier = 'SSH-1.5-phpseclib';
@@ -232,7 +265,7 @@
     /**
      * The Socket Object
      *
-     * @var object
+     * @var Object
      * @access private
      */
     var $fsock;
@@ -240,7 +273,7 @@
     /**
      * The cryptography object
      *
-     * @var object
+     * @var Object
      * @access private
      */
     var $crypto = false;
@@ -248,10 +281,10 @@
     /**
      * Execution Bitmap
      *
-     * The bits that are set represent functions that have been called already.  This is used to determine
+     * The bits that are set reprsent functions that have been called already.  This is used to determine
      * if a requisite function has been successfully executed.  If not, an error should be thrown.
      *
-     * @var int
+     * @var Integer
      * @access private
      */
     var $bitmap = 0;
@@ -261,8 +294,8 @@
      *
      * Logged for debug purposes
      *
-     * @see self::getServerKeyPublicExponent()
-     * @var string
+     * @see Net_SSH1::getServerKeyPublicExponent()
+     * @var String
      * @access private
      */
     var $server_key_public_exponent;
@@ -272,8 +305,8 @@
      *
      * Logged for debug purposes
      *
-     * @see self::getServerKeyPublicModulus()
-     * @var string
+     * @see Net_SSH1::getServerKeyPublicModulus()
+     * @var String
      * @access private
      */
     var $server_key_public_modulus;
@@ -283,8 +316,8 @@
      *
      * Logged for debug purposes
      *
-     * @see self::getHostKeyPublicExponent()
-     * @var string
+     * @see Net_SSH1::getHostKeyPublicExponent()
+     * @var String
      * @access private
      */
     var $host_key_public_exponent;
@@ -294,8 +327,8 @@
      *
      * Logged for debug purposes
      *
-     * @see self::getHostKeyPublicModulus()
-     * @var string
+     * @see Net_SSH1::getHostKeyPublicModulus()
+     * @var String
      * @access private
      */
     var $host_key_public_modulus;
@@ -305,18 +338,18 @@
      *
      * Logged for debug purposes
      *
-     * @see self::getSupportedCiphers()
-     * @var array
+     * @see Net_SSH1::getSupportedCiphers()
+     * @var Array
      * @access private
      */
     var $supported_ciphers = array(
-        self::CIPHER_NONE       => 'No encryption',
-        self::CIPHER_IDEA       => 'IDEA in CFB mode',
-        self::CIPHER_DES        => 'DES in CBC mode',
-        self::CIPHER_3DES       => 'Triple-DES in CBC mode',
-        self::CIPHER_BROKEN_TSS => 'TRI\'s Simple Stream encryption CBC',
-        self::CIPHER_RC4        => 'RC4',
-        self::CIPHER_BLOWFISH   => 'Blowfish'
+        NET_SSH1_CIPHER_NONE       => 'No encryption',
+        NET_SSH1_CIPHER_IDEA       => 'IDEA in CFB mode',
+        NET_SSH1_CIPHER_DES        => 'DES in CBC mode',
+        NET_SSH1_CIPHER_3DES       => 'Triple-DES in CBC mode',
+        NET_SSH1_CIPHER_BROKEN_TSS => 'TRI\'s Simple Stream encryption CBC',
+        NET_SSH1_CIPHER_RC4        => 'RC4',
+        NET_SSH1_CIPHER_BLOWFISH   => 'Blowfish'
     );
 
     /**
@@ -324,309 +357,99 @@
      *
      * Logged for debug purposes
      *
-     * @see self::getSupportedAuthentications()
-     * @var array
+     * @see Net_SSH1::getSupportedAuthentications()
+     * @var Array
      * @access private
      */
     var $supported_authentications = array(
-        self::AUTH_RHOSTS     => '.rhosts or /etc/hosts.equiv',
-        self::AUTH_RSA        => 'pure RSA authentication',
-        self::AUTH_PASSWORD   => 'password authentication',
-        self::AUTH_RHOSTS_RSA => '.rhosts with RSA host authentication'
+        NET_SSH1_AUTH_RHOSTS     => '.rhosts or /etc/hosts.equiv',
+        NET_SSH1_AUTH_RSA        => 'pure RSA authentication',
+        NET_SSH1_AUTH_PASSWORD   => 'password authentication',
+        NET_SSH1_AUTH_RHOSTS_RSA => '.rhosts with RSA host authentication'
     );
 
     /**
      * Server Identification
      *
-     * @see self::getServerIdentification()
-     * @var string
+     * @see Net_SSH1::getServerIdentification()
+     * @var String
      * @access private
      */
     var $server_identification = '';
 
     /**
-     * Protocol Flags
-     *
-     * @see self::__construct()
-     * @var array
-     * @access private
-     */
-    var $protocol_flags = array();
-
-    /**
-     * Protocol Flag Log
-     *
-     * @see self::getLog()
-     * @var array
-     * @access private
-     */
-    var $protocol_flag_log = array();
-
-    /**
-     * Message Log
-     *
-     * @see self::getLog()
-     * @var array
-     * @access private
-     */
-    var $message_log = array();
-
-    /**
-     * Real-time log file pointer
-     *
-     * @see self::_append_log()
-     * @var resource
-     * @access private
-     */
-    var $realtime_log_file;
-
-    /**
-     * Real-time log file size
-     *
-     * @see self::_append_log()
-     * @var int
-     * @access private
-     */
-    var $realtime_log_size;
-
-    /**
-     * Real-time log file wrap boolean
-     *
-     * @see self::_append_log()
-     * @var bool
-     * @access private
-     */
-    var $realtime_log_wrap;
-
-    /**
-     * Interactive Buffer
-     *
-     * @see self::read()
-     * @var array
-     * @access private
-     */
-    var $interactiveBuffer = '';
-
-    /**
-     * Timeout
-     *
-     * @see self::setTimeout()
-     * @access private
-     */
-    var $timeout;
-
-    /**
-     * Current Timeout
-     *
-     * @see self::_get_channel_packet()
-     * @access private
-     */
-    var $curTimeout;
-
-    /**
-     * Log Boundary
-     *
-     * @see self::_format_log()
-     * @access private
-     */
-    var $log_boundary = ':';
-
-    /**
-     * Log Long Width
-     *
-     * @see self::_format_log()
-     * @access private
-     */
-    var $log_long_width = 65;
-
-    /**
-     * Log Short Width
-     *
-     * @see self::_format_log()
-     * @access private
-     */
-    var $log_short_width = 16;
-
-    /**
-     * Hostname
-     *
-     * @see self::__construct()
-     * @see self::_connect()
-     * @var string
-     * @access private
-     */
-    var $host;
-
-    /**
-     * Port Number
-     *
-     * @see self::__construct()
-     * @see self::_connect()
-     * @var int
-     * @access private
-     */
-    var $port;
-
-    /**
-     * Timeout for initial connection
-     *
-     * Set by the constructor call. Calling setTimeout() is optional. If it's not called functions like
-     * exec() won't timeout unless some PHP setting forces it too. The timeout specified in the constructor,
-     * however, is non-optional. There will be a timeout, whether or not you set it. If you don't it'll be
-     * 10 seconds. It is used by fsockopen() in that function.
-     *
-     * @see self::__construct()
-     * @see self::_connect()
-     * @var int
-     * @access private
-     */
-    var $connectionTimeout;
-
-    /**
-     * Default cipher
-     *
-     * @see self::__construct()
-     * @see self::_connect()
-     * @var int
-     * @access private
-     */
-    var $cipher;
-
-    /**
      * Default Constructor.
      *
      * Connects to an SSHv1 server
      *
-     * @param string $host
-     * @param int $port
-     * @param int $timeout
-     * @param int $cipher
-     * @return \phpseclib\Net\SSH1
+     * @param String $host
+     * @param optional Integer $port
+     * @param optional Integer $timeout
+     * @param optional Integer $cipher
+     * @return Net_SSH1
      * @access public
      */
-    function __construct($host, $port = 22, $timeout = 10, $cipher = self::CIPHER_3DES)
+    function Net_SSH1($host, $port = 22, $timeout = 10, $cipher = NET_SSH1_CIPHER_3DES)
     {
-        $this->protocol_flags = array(
-            1  => 'NET_SSH1_MSG_DISCONNECT',
-            2  => 'NET_SSH1_SMSG_PUBLIC_KEY',
-            3  => 'NET_SSH1_CMSG_SESSION_KEY',
-            4  => 'NET_SSH1_CMSG_USER',
-            9  => 'NET_SSH1_CMSG_AUTH_PASSWORD',
-            10 => 'NET_SSH1_CMSG_REQUEST_PTY',
-            12 => 'NET_SSH1_CMSG_EXEC_SHELL',
-            13 => 'NET_SSH1_CMSG_EXEC_CMD',
-            14 => 'NET_SSH1_SMSG_SUCCESS',
-            15 => 'NET_SSH1_SMSG_FAILURE',
-            16 => 'NET_SSH1_CMSG_STDIN_DATA',
-            17 => 'NET_SSH1_SMSG_STDOUT_DATA',
-            18 => 'NET_SSH1_SMSG_STDERR_DATA',
-            19 => 'NET_SSH1_CMSG_EOF',
-            20 => 'NET_SSH1_SMSG_EXITSTATUS',
-            33 => 'NET_SSH1_CMSG_EXIT_CONFIRMATION'
-        );
-
-        $this->_define_array($this->protocol_flags);
-
-        $this->host = $host;
-        $this->port = $port;
-        $this->connectionTimeout = $timeout;
-        $this->cipher = $cipher;
-    }
-
-    /**
-     * Connect to an SSHv1 server
-     *
-     * @return bool
-     * @access private
-     */
-    function _connect()
-    {
-        $this->fsock = @fsockopen($this->host, $this->port, $errno, $errstr, $this->connectionTimeout);
+        $this->fsock = @fsockopen($host, $port, $errno, $errstr, $timeout);
         if (!$this->fsock) {
-            user_error(rtrim("Cannot connect to {$this->host}:{$this->port}. Error $errno. $errstr"));
-            return false;
+            user_error(rtrim("Cannot connect to $host. Error $errno. $errstr"), E_USER_NOTICE);
+            return;
         }
 
         $this->server_identification = $init_line = fgets($this->fsock, 255);
-
-        if (defined('NET_SSH1_LOGGING')) {
-            $this->_append_log('<-', $this->server_identification);
-            $this->_append_log('->', $this->identifier . "\r\n");
-        }
-
         if (!preg_match('#SSH-([0-9\.]+)-(.+)#', $init_line, $parts)) {
-            user_error('Can only connect to SSH servers');
-            return false;
+            user_error('Can only connect to SSH servers', E_USER_NOTICE);
+            return;
         }
         if ($parts[1][0] != 1) {
-            user_error("Cannot connect to SSH $parts[1] servers");
-            return false;
+            user_error("Cannot connect to SSH $parts[1] servers", E_USER_NOTICE);
+            return;
         }
 
         fputs($this->fsock, $this->identifier."\r\n");
 
         $response = $this->_get_binary_packet();
-        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_PUBLIC_KEY) {
-            user_error('Expected SSH_SMSG_PUBLIC_KEY');
-            return false;
+        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_PUBLIC_KEY) {
+            user_error('Expected SSH_SMSG_PUBLIC_KEY', E_USER_NOTICE);
+            return;
         }
 
-        $anti_spoofing_cookie = $this->_string_shift($response[self::RESPONSE_DATA], 8);
+        $anti_spoofing_cookie = $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 8);
 
-        $this->_string_shift($response[self::RESPONSE_DATA], 4);
+        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
 
-        if (strlen($response[self::RESPONSE_DATA]) < 2) {
-            return false;
-        }
-        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
-        $server_key_public_exponent = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
+        $server_key_public_exponent = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->server_key_public_exponent = $server_key_public_exponent;
 
-        if (strlen($response[self::RESPONSE_DATA]) < 2) {
-            return false;
-        }
-        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
-        $server_key_public_modulus = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
-
+        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
+        $server_key_public_modulus = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->server_key_public_modulus = $server_key_public_modulus;
 
-        $this->_string_shift($response[self::RESPONSE_DATA], 4);
+        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
 
-        if (strlen($response[self::RESPONSE_DATA]) < 2) {
-            return false;
-        }
-        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
-        $host_key_public_exponent = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
+        $host_key_public_exponent = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->host_key_public_exponent = $host_key_public_exponent;
 
-        if (strlen($response[self::RESPONSE_DATA]) < 2) {
-            return false;
-        }
-        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
-        $host_key_public_modulus = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
-
+        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
+        $host_key_public_modulus = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->host_key_public_modulus = $host_key_public_modulus;
 
-        $this->_string_shift($response[self::RESPONSE_DATA], 4);
+        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
 
         // get a list of the supported ciphers
-        if (strlen($response[self::RESPONSE_DATA]) < 4) {
-            return false;
-        }
-        extract(unpack('Nsupported_ciphers_mask', $this->_string_shift($response[self::RESPONSE_DATA], 4)));
-
-        foreach ($this->supported_ciphers as $mask => $name) {
+        extract(unpack('Nsupported_ciphers_mask', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4)));
+        foreach ($this->supported_ciphers as $mask=>$name) {
             if (($supported_ciphers_mask & (1 << $mask)) == 0) {
                 unset($this->supported_ciphers[$mask]);
             }
         }
 
         // get a list of the supported authentications
-        if (strlen($response[self::RESPONSE_DATA]) < 4) {
-            return false;
-        }
-        extract(unpack('Nsupported_authentications_mask', $this->_string_shift($response[self::RESPONSE_DATA], 4)));
-        foreach ($this->supported_authentications as $mask => $name) {
+        extract(unpack('Nsupported_authentications_mask', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4)));
+        foreach ($this->supported_authentications as $mask=>$name) {
             if (($supported_authentications_mask & (1 << $mask)) == 0) {
                 unset($this->supported_authentications[$mask]);
             }
@@ -634,7 +457,10 @@
 
         $session_id = pack('H*', md5($host_key_public_modulus->toBytes() . $server_key_public_modulus->toBytes() . $anti_spoofing_cookie));
 
-        $session_key = Random::string(32);
+        $session_key = '';
+        for ($i = 0; $i < 32; $i++) {
+            $session_key.= chr(crypt_random(0, 255));
+        }
         $double_encrypted_session_key = $session_key ^ str_pad($session_id, 32, chr(0));
 
         if ($server_key_public_modulus->compare($host_key_public_modulus) < 0) {
@@ -669,32 +495,32 @@
             );
         }
 
-        $cipher = isset($this->supported_ciphers[$this->cipher]) ? $this->cipher : self::CIPHER_3DES;
+        $cipher = isset($this->supported_ciphers[$cipher]) ? $cipher : NET_SSH1_CIPHER_3DES;
         $data = pack('C2a*na*N', NET_SSH1_CMSG_SESSION_KEY, $cipher, $anti_spoofing_cookie, 8 * strlen($double_encrypted_session_key), $double_encrypted_session_key, 0);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_SESSION_KEY');
-            return false;
+            user_error('Error sending SSH_CMSG_SESSION_KEY', E_USER_NOTICE);
+            return;
         }
 
         switch ($cipher) {
-            //case self::CIPHER_NONE:
-            //    $this->crypto = new \phpseclib\Crypt\Null();
+            //case NET_SSH1_CIPHER_NONE:
+            //    $this->crypto = new Crypt_Null();
             //    break;
-            case self::CIPHER_DES:
-                $this->crypto = new DES();
+            case NET_SSH1_CIPHER_DES:
+                $this->crypto = new Crypt_DES();
                 $this->crypto->disablePadding();
                 $this->crypto->enableContinuousBuffer();
                 $this->crypto->setKey(substr($session_key, 0,  8));
                 break;
-            case self::CIPHER_3DES:
-                $this->crypto = new TripleDES(TripleDES::MODE_3CBC);
+            case NET_SSH1_CIPHER_3DES:
+                $this->crypto = new Crypt_TripleDES(CRYPT_DES_MODE_3CBC);
                 $this->crypto->disablePadding();
                 $this->crypto->enableContinuousBuffer();
                 $this->crypto->setKey(substr($session_key, 0, 24));
                 break;
-            //case self::CIPHER_RC4:
-            //    $this->crypto = new RC4();
+            //case NET_SSH1_CIPHER_RC4:
+            //    $this->crypto = new Crypt_RC4();
             //    $this->crypto->enableContinuousBuffer();
             //    $this->crypto->setKey(substr($session_key, 0,  16));
             //    break;
@@ -702,100 +528,66 @@
 
         $response = $this->_get_binary_packet();
 
-        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS');
-            return false;
+        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
+            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
+            return;
         }
 
-        $this->bitmap = self::MASK_CONNECTED;
-
-        return true;
+        $this->bitmap = NET_SSH1_MASK_CONSTRUCTOR;
     }
 
     /**
      * Login
      *
-     * @param string $username
-     * @param string $password
-     * @return bool
+     * @param String $username
+     * @param optional String $password
+     * @return Boolean
      * @access public
      */
     function login($username, $password = '')
     {
-        if (!($this->bitmap & self::MASK_CONSTRUCTOR)) {
-            $this->bitmap |= self::MASK_CONSTRUCTOR;
-            if (!$this->_connect()) {
-                return false;
-            }
-        }
-
-        if (!($this->bitmap & self::MASK_CONNECTED)) {
+        if (!($this->bitmap & NET_SSH1_MASK_CONSTRUCTOR)) {
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_USER, strlen($username), $username);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_USER');
+            user_error('Error sending SSH_CMSG_USER', E_USER_NOTICE);
             return false;
         }
 
         $response = $this->_get_binary_packet();
 
-        if ($response === true) {
-            return false;
-        }
-        if ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
-            $this->bitmap |= self::MASK_LOGIN;
+        if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
+            $this->bitmap |= NET_SSH1_MASK_LOGIN;
             return true;
-        } elseif ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_FAILURE) {
-            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE');
+        } else if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_FAILURE) {
+            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE', E_USER_NOTICE);
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_AUTH_PASSWORD, strlen($password), $password);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_AUTH_PASSWORD');
+            user_error('Error sending SSH_CMSG_AUTH_PASSWORD', E_USER_NOTICE);
             return false;
         }
 
-        // remove the username and password from the last logged packet
-        if (defined('NET_SSH1_LOGGING') && NET_SSH1_LOGGING == self::LOG_COMPLEX) {
-            $data = pack('CNa*', NET_SSH1_CMSG_AUTH_PASSWORD, strlen('password'), 'password');
-            $this->message_log[count($this->message_log) - 1] = $data;
-        }
-
         $response = $this->_get_binary_packet();
 
-        if ($response === true) {
-            return false;
-        }
-        if ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
-            $this->bitmap |= self::MASK_LOGIN;
+        if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
+            $this->bitmap |= NET_SSH1_MASK_LOGIN;
             return true;
-        } elseif ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_FAILURE) {
+        } else if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_FAILURE) {
             return false;
         } else {
-            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE');
+            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE', E_USER_NOTICE);
             return false;
         }
     }
 
     /**
-     * Set Timeout
-     *
-     * $ssh->exec('ping 127.0.0.1'); on a Linux host will never return and will run indefinitely.  setTimeout() makes it so it'll timeout.
-     * Setting $timeout to false or 0 will mean there is no timeout.
-     *
-     * @param mixed $timeout
-     */
-    function setTimeout($timeout)
-    {
-        $this->timeout = $this->curTimeout = $timeout;
-    }
-
-    /**
      * Executes a command on a non-interactive shell, returns the output, and quits.
      *
      * An SSH1 server will close the connection after a command has been executed on a non-interactive shell.  SSH2
@@ -805,43 +597,54 @@
      * {@link http://www.faqs.org/docs/bashman/bashref_65.html http://www.faqs.org/docs/bashman/bashref_65.html}
      * {@link http://www.faqs.org/docs/bashman/bashref_62.html http://www.faqs.org/docs/bashman/bashref_62.html}
      *
-     * To execute further commands, a new \phpseclib\Net\SSH1 object will need to be created.
+     * To execute further commands, a new Net_SSH1 object will need to be created.
      *
      * Returns false on failure and the output, otherwise.
      *
-     * @see self::interactiveRead()
-     * @see self::interactiveWrite()
-     * @param string $cmd
+     * @see Net_SSH1::interactiveRead()
+     * @see Net_SSH1::interactiveWrite()
+     * @param String $cmd
      * @return mixed
      * @access public
      */
-    function exec($cmd, $block = true)
+    function exec($cmd)
     {
-        if (!($this->bitmap & self::MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()');
+        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
             return false;
         }
 
-        $data = pack('CNa*', NET_SSH1_CMSG_EXEC_CMD, strlen($cmd), $cmd);
+        // connect using the sample parameters in protocol-1.5.txt.
+        // according to wikipedia.org's entry on text terminals, "the fundamental type of application running on a text
+        // terminal is a command line interpreter or shell".  thus, opening a terminal session to run the shell.
+        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, NET_SSH1_TTY_OP_END);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_EXEC_CMD');
+            user_error('Error sending SSH_CMSG_REQUEST_PTY', E_USER_NOTICE);
+            return false;
+        }
+
+        $response = $this->_get_binary_packet();
+
+        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
+            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
             return false;
         }
 
-        if (!$block) {
-            return true;
+        $data = pack('CNa*', NET_SSH1_CMSG_EXEC_CMD, strlen($cmd), $cmd);
+
+        if (!$this->_send_binary_packet($data)) {
+            user_error('Error sending SSH_CMSG_EXEC_CMD', E_USER_NOTICE);
+            return false;
         }
 
         $output = '';
         $response = $this->_get_binary_packet();
 
-        if ($response !== false) {
-            do {
-                $output.= substr($response[self::RESPONSE_DATA], 4);
-                $response = $this->_get_binary_packet();
-            } while (is_array($response) && $response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_EXITSTATUS);
-        }
+        do {
+            $output.= substr($response[NET_SSH1_RESPONSE_DATA], 4);
+            $response = $this->_get_binary_packet();
+        } while ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_EXITSTATUS);
 
         $data = pack('C', NET_SSH1_CMSG_EXIT_CONFIRMATION);
 
@@ -850,7 +653,7 @@
 
         fclose($this->fsock);
 
-        // reset the execution bitmap - a new \phpseclib\Net\SSH1 object needs to be created.
+        // reset the execution bitmap - a new Net_SSH1 object needs to be created.
         $this->bitmap = 0;
 
         return $output;
@@ -859,41 +662,35 @@
     /**
      * Creates an interactive shell
      *
-     * @see self::interactiveRead()
-     * @see self::interactiveWrite()
-     * @return bool
+     * @see Net_SSH1::interactiveRead()
+     * @see Net_SSH1::interactiveWrite()
+     * @return Boolean
      * @access private
      */
     function _initShell()
     {
-        // connect using the sample parameters in protocol-1.5.txt.
-        // according to wikipedia.org's entry on text terminals, "the fundamental type of application running on a text
-        // terminal is a command line interpreter or shell".  thus, opening a terminal session to run the shell.
-        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, self::TTY_OP_END);
+        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, NET_SSH1_TTY_OP_END);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_REQUEST_PTY');
+            user_error('Error sending SSH_CMSG_REQUEST_PTY', E_USER_NOTICE);
             return false;
         }
 
         $response = $this->_get_binary_packet();
 
-        if ($response === true) {
-            return false;
-        }
-        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS');
+        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
+            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
             return false;
         }
 
         $data = pack('C', NET_SSH1_CMSG_EXEC_SHELL);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_EXEC_SHELL');
+            user_error('Error sending SSH_CMSG_EXEC_SHELL', E_USER_NOTICE);
             return false;
         }
 
-        $this->bitmap |= self::MASK_SHELL;
+        $this->bitmap |= NET_SSH1_MASK_SHELL;
 
         //stream_set_blocking($this->fsock, 0);
 
@@ -903,83 +700,27 @@
     /**
      * Inputs a command into an interactive shell.
      *
-     * @see self::interactiveWrite()
-     * @param string $cmd
-     * @return bool
-     * @access public
-     */
-    function write($cmd)
-    {
-        return $this->interactiveWrite($cmd);
-    }
-
-    /**
-     * Returns the output of an interactive shell when there's a match for $expect
-     *
-     * $expect can take the form of a string literal or, if $mode == self::READ_REGEX,
-     * a regular expression.
-     *
-     * @see self::write()
-     * @param string $expect
-     * @param int $mode
-     * @return bool
-     * @access public
-     */
-    function read($expect, $mode = self::READ_SIMPLE)
-    {
-        if (!($this->bitmap & self::MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()');
-            return false;
-        }
-
-        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
-            user_error('Unable to initiate an interactive shell session');
-            return false;
-        }
-
-        $match = $expect;
-        while (true) {
-            if ($mode == self::READ_REGEX) {
-                preg_match($expect, $this->interactiveBuffer, $matches);
-                $match = isset($matches[0]) ? $matches[0] : '';
-            }
-            $pos = strlen($match) ? strpos($this->interactiveBuffer, $match) : false;
-            if ($pos !== false) {
-                return $this->_string_shift($this->interactiveBuffer, $pos + strlen($match));
-            }
-            $response = $this->_get_binary_packet();
-
-            if ($response === true) {
-                return $this->_string_shift($this->interactiveBuffer, strlen($this->interactiveBuffer));
-            }
-            $this->interactiveBuffer.= substr($response[self::RESPONSE_DATA], 4);
-        }
-    }
-
-    /**
-     * Inputs a command into an interactive shell.
-     *
-     * @see self::interactiveRead()
-     * @param string $cmd
-     * @return bool
+     * @see Net_SSH1::interactiveRead()
+     * @param String $cmd
+     * @return Boolean
      * @access public
      */
     function interactiveWrite($cmd)
     {
-        if (!($this->bitmap & self::MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()');
+        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
             return false;
         }
 
-        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
-            user_error('Unable to initiate an interactive shell session');
+        if (!($this->bitmap & NET_SSH1_MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session', E_USER_NOTICE);
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_STDIN_DATA, strlen($cmd), $cmd);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_STDIN');
+            user_error('Error sending SSH_CMSG_STDIN', E_USER_NOTICE);
             return false;
         }
 
@@ -987,27 +728,27 @@
     }
 
     /**
-     * Returns the output of an interactive shell when no more output is available.
+     * Reads the output of an interactive shell.
      *
      * Requires PHP 4.3.0 or later due to the use of the stream_select() function.  If you see stuff like
-     * "^[[00m", you're seeing ANSI escape codes.  According to
+     * "[00m", you're seeing ANSI escape codes.  According to
      * {@link http://support.microsoft.com/kb/101875 How to Enable ANSI.SYS in a Command Window}, "Windows NT
      * does not support ANSI escape sequences in Win32 Console applications", so if you're a Windows user,
      * there's not going to be much recourse.
      *
-     * @see self::interactiveRead()
-     * @return string
+     * @see Net_SSH1::interactiveRead()
+     * @return String
      * @access public
      */
     function interactiveRead()
     {
-        if (!($this->bitmap & self::MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()');
+        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
             return false;
         }
 
-        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
-            user_error('Unable to initiate an interactive shell session');
+        if (!($this->bitmap & NET_SSH1_MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session', E_USER_NOTICE);
             return false;
         }
 
@@ -1015,7 +756,7 @@
         $write = $except = null;
         if (stream_select($read, $write, $except, 0)) {
             $response = $this->_get_binary_packet();
-            return substr($response[self::RESPONSE_DATA], 4);
+            return substr($response[NET_SSH1_RESPONSE_DATA], 4);
         } else {
             return '';
         }
@@ -1047,29 +788,13 @@
     /**
      * Disconnect
      *
-     * @param string $msg
+     * @param String $msg
      * @access private
      */
     function _disconnect($msg = 'Client Quit')
     {
         if ($this->bitmap) {
-            $data = pack('C', NET_SSH1_CMSG_EOF);
-            $this->_send_binary_packet($data);
-            /*
-            $response = $this->_get_binary_packet();
-            if ($response === true) {
-                $response = array(self::RESPONSE_TYPE => -1);
-            }
-            switch ($response[self::RESPONSE_TYPE]) {
-                case NET_SSH1_SMSG_EXITSTATUS:
-                    $data = pack('C', NET_SSH1_CMSG_EXIT_CONFIRMATION);
-                    break;
-                default:
-                    $data = pack('CNa*', NET_SSH1_MSG_DISCONNECT, strlen($msg), $msg);
-            }
-            */
             $data = pack('CNa*', NET_SSH1_MSG_DISCONNECT, strlen($msg), $msg);
-
             $this->_send_binary_packet($data);
             fclose($this->fsock);
             $this->bitmap = 0;
@@ -1084,52 +809,25 @@
      * Also, this function could be improved upon by adding detection for the following exploit:
      * http://www.securiteam.com/securitynews/5LP042K3FY.html
      *
-     * @see self::_send_binary_packet()
-     * @return array
+     * @see Net_SSH1::_send_binary_packet()
+     * @return Array
      * @access private
      */
     function _get_binary_packet()
     {
         if (feof($this->fsock)) {
-            //user_error('connection closed prematurely');
+            //user_error('connection closed prematurely', E_USER_NOTICE);
             return false;
         }
 
-        if ($this->curTimeout) {
-            $read = array($this->fsock);
-            $write = $except = null;
-
-            $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
-            $sec = floor($this->curTimeout);
-            $usec = 1000000 * ($this->curTimeout - $sec);
-            // on windows this returns a "Warning: Invalid CRT parameters detected" error
-            if (!@stream_select($read, $write, $except, $sec, $usec) && !count($read)) {
-                //$this->_disconnect('Timeout');
-                return true;
-            }
-            $elapsed = strtok(microtime(), ' ') + strtok('') - $start;
-            $this->curTimeout-= $elapsed;
-        }
-
-        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
-        $data = fread($this->fsock, 4);
-        if (strlen($data) < 4) {
-            return false;
-        }
-        $temp = unpack('Nlength', $data);
+        $temp = unpack('Nlength', fread($this->fsock, 4));
 
         $padding_length = 8 - ($temp['length'] & 7);
         $length = $temp['length'] + $padding_length;
-        $raw = '';
 
-        while ($length > 0) {
-            $temp = fread($this->fsock, $length);
-            $raw.= $temp;
-            $length-= strlen($temp);
-        }
-        $stop = strtok(microtime(), ' ') + strtok('');
+        $raw = fread($this->fsock, $length);
 
-        if (strlen($raw) && $this->crypto !== false) {
+        if ($this->crypto !== false) {
             $raw = $this->crypto->decrypt($raw);
         }
 
@@ -1137,28 +835,16 @@
         $type = $raw[$padding_length];
         $data = substr($raw, $padding_length + 1, -4);
 
-        if (strlen($raw) < 4) {
-            return false;
-        }
         $temp = unpack('Ncrc', substr($raw, -4));
 
         //if ( $temp['crc'] != $this->_crc($padding . $type . $data) ) {
-        //    user_error('Bad CRC in packet from server');
+        //    user_error('Bad CRC in packet from server', E_USER_NOTICE);
         //    return false;
         //}
 
-        $type = ord($type);
-
-        if (defined('NET_SSH1_LOGGING')) {
-            $temp = isset($this->protocol_flags[$type]) ? $this->protocol_flags[$type] : 'UNKNOWN';
-            $temp = '<- ' . $temp .
-                    ' (' . round($stop - $start, 4) . 's)';
-            $this->_append_log($temp, $data);
-        }
-
         return array(
-            self::RESPONSE_TYPE => $type,
-            self::RESPONSE_DATA => $data
+            NET_SSH1_RESPONSE_TYPE => ord($type),
+            NET_SSH1_RESPONSE_DATA => $data
         );
     }
 
@@ -1167,23 +853,25 @@
      *
      * Returns true on success, false on failure.
      *
-     * @see self::_get_binary_packet()
-     * @param string $data
-     * @return bool
+     * @see Net_SSH1::_get_binary_packet()
+     * @param String $data
+     * @return Boolean
      * @access private
      */
-    function _send_binary_packet($data)
-    {
+    function _send_binary_packet($data) {
         if (feof($this->fsock)) {
-            //user_error('connection closed prematurely');
+            //user_error('connection closed prematurely', E_USER_NOTICE);
             return false;
         }
 
         $length = strlen($data) + 4;
 
-        $padding = Random::string(8 - ($length & 7));
+        $padding_length = 8 - ($length & 7);
+        $padding = '';
+        for ($i = 0; $i < $padding_length; $i++) {
+            $padding.= chr(crypt_random(0, 255));
+        }
 
-        $orig = $data;
         $data = $padding . $data;
         $data.= pack('N', $this->_crc($data));
 
@@ -1193,18 +881,7 @@
 
         $packet = pack('Na*', $length, $data);
 
-        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
-        $result = strlen($packet) == fputs($this->fsock, $packet);
-        $stop = strtok(microtime(), ' ') + strtok('');
-
-        if (defined('NET_SSH1_LOGGING')) {
-            $temp = isset($this->protocol_flags[ord($orig[0])]) ? $this->protocol_flags[ord($orig[0])] : 'UNKNOWN';
-            $temp = '-> ' . $temp .
-                    ' (' . round($stop - $start, 4) . 's)';
-            $this->_append_log($temp, $orig);
-        }
-
-        return $result;
+        return strlen($packet) == fputs($this->fsock, $packet);
     }
 
     /**
@@ -1214,10 +891,10 @@
      * we've reimplemented it. A more detailed discussion of the differences can be found after
      * $crc_lookup_table's initialization.
      *
-     * @see self::_get_binary_packet()
-     * @see self::_send_binary_packet()
-     * @param string $data
-     * @return int
+     * @see Net_SSH1::_get_binary_packet()
+     * @see Net_SSH1::_send_binary_packet()
+     * @param String $data
+     * @return Integer
      * @access private
      */
     function _crc($data)
@@ -1294,7 +971,7 @@
         $crc = 0x00000000;
         $length = strlen($data);
 
-        for ($i=0; $i<$length; $i++) {
+        for ($i=0;$i<$length;$i++) {
             // We AND $crc >> 8 with 0x00FFFFFF because we want the eight newly added bits to all
             // be zero.  PHP, unfortunately, doesn't always do this.  0x80000000 >> 8, as an example,
             // yields 0xFF800000 - not 0x00800000.  The following link elaborates:
@@ -1312,9 +989,9 @@
      *
      * Inspired by array_shift
      *
-     * @param string $string
-     * @param int $index
-     * @return string
+     * @param String $string
+     * @param optional Integer $index
+     * @return String
      * @access private
      */
     function _string_shift(&$string, $index = 1)
@@ -1331,18 +1008,22 @@
      * should be a number with the property that gcd($e, ($p - 1) * ($q - 1)) == 1.  Could just make anything that
      * calls this call modexp, instead, but I think this makes things clearer, maybe...
      *
-     * @see self::__construct()
-     * @param BigInteger $m
-     * @param array $key
-     * @return BigInteger
+     * @see Net_SSH1::Net_SSH1()
+     * @param Math_BigInteger $m
+     * @param Array $key
+     * @return Math_BigInteger
      * @access private
      */
     function _rsa_crypt($m, $key)
     {
         /*
-        $rsa = new RSA();
-        $rsa->loadKey($key, RSA::PUBLIC_FORMAT_RAW);
-        $rsa->setEncryptionMode(RSA::ENCRYPTION_PKCS1);
+        if (!class_exists('Crypt_RSA')) {
+            require_once('Crypt/RSA.php');
+        }
+
+        $rsa = new Crypt_RSA();
+        $rsa->loadKey($key, CRYPT_RSA_PUBLIC_FORMAT_RAW);
+        $rsa->setEncryptionMode(CRYPT_RSA_ENCRYPTION_PKCS1);
         return $rsa->encrypt($m);
         */
 
@@ -1359,128 +1040,28 @@
         // Presumably the part of PKCS#1 they're refering to is "Section 7.2.1 Encryption Operation",
         // under "7.2 RSAES-PKCS1-v1.5" and "7 Encryption schemes" of the following URL:
         // ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf
+        $temp = chr(0) . chr(2);
         $modulus = $key[1]->toBytes();
         $length = strlen($modulus) - strlen($m) - 3;
-        $random = '';
-        while (strlen($random) != $length) {
-            $block = Random::string($length - strlen($random));
-            $block = str_replace("\x00", '', $block);
-            $random.= $block;
+        for ($i = 0; $i < $length; $i++) {
+            $temp.= chr(crypt_random(1, 255));
         }
-        $temp = chr(0) . chr(2) . $random . chr(0) . $m;
+        $temp.= chr(0) . $m;
 
-        $m = new BigInteger($temp, 256);
+        $m = new Math_BigInteger($temp, 256);
         $m = $m->modPow($key[0], $key[1]);
 
         return $m->toBytes();
     }
 
     /**
-     * Define Array
-     *
-     * Takes any number of arrays whose indices are integers and whose values are strings and defines a bunch of
-     * named constants from it, using the value as the name of the constant and the index as the value of the constant.
-     * If any of the constants that would be defined already exists, none of the constants will be defined.
-     *
-     * @param array $array
-     * @access private
-     */
-    function _define_array()
-    {
-        $args = func_get_args();
-        foreach ($args as $arg) {
-            foreach ($arg as $key => $value) {
-                if (!defined($value)) {
-                    define($value, $key);
-                } else {
-                    break 2;
-                }
-            }
-        }
-    }
-
-    /**
-     * Returns a log of the packets that have been sent and received.
-     *
-     * Returns a string if NET_SSH1_LOGGING == self::LOG_COMPLEX, an array if NET_SSH1_LOGGING == self::LOG_SIMPLE and false if !defined('NET_SSH1_LOGGING')
-     *
-     * @access public
-     * @return array|false|string
-     */
-    function getLog()
-    {
-        if (!defined('NET_SSH1_LOGGING')) {
-            return false;
-        }
-
-        switch (NET_SSH1_LOGGING) {
-            case self::LOG_SIMPLE:
-                return $this->message_number_log;
-                break;
-            case self::LOG_COMPLEX:
-                return $this->_format_log($this->message_log, $this->protocol_flags_log);
-                break;
-            default:
-                return false;
-        }
-    }
-
-    /**
-     * Formats a log for printing
-     *
-     * @param array $message_log
-     * @param array $message_number_log
-     * @access private
-     * @return string
-     */
-    function _format_log($message_log, $message_number_log)
-    {
-        $output = '';
-        for ($i = 0; $i < count($message_log); $i++) {
-            $output.= $message_number_log[$i] . "\r\n";
-            $current_log = $message_log[$i];
-            $j = 0;
-            do {
-                if (strlen($current_log)) {
-                    $output.= str_pad(dechex($j), 7, '0', STR_PAD_LEFT) . '0  ';
-                }
-                $fragment = $this->_string_shift($current_log, $this->log_short_width);
-                $hex = substr(preg_replace_callback('#.#s', array($this, '_format_log_helper'), $fragment), strlen($this->log_boundary));
-                // replace non ASCII printable characters with dots
-                // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
-                // also replace < with a . since < messes up the output on web browsers
-                $raw = preg_replace('#[^\x20-\x7E]|<#', '.', $fragment);
-                $output.= str_pad($hex, $this->log_long_width - $this->log_short_width, ' ') . $raw . "\r\n";
-                $j++;
-            } while (strlen($current_log));
-            $output.= "\r\n";
-        }
-
-        return $output;
-    }
-
-    /**
-     * Helper function for _format_log
-     *
-     * For use with preg_replace_callback()
-     *
-     * @param array $matches
-     * @access private
-     * @return string
-     */
-    function _format_log_helper($matches)
-    {
-        return $this->log_boundary . str_pad(dechex(ord($matches[0])), 2, '0', STR_PAD_LEFT);
-    }
-
-    /**
      * Return the server key public exponent
      *
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param bool $raw_output
-     * @return string
+     * @param optional Boolean $raw_output
+     * @return String
      * @access public
      */
     function getServerKeyPublicExponent($raw_output = false)
@@ -1494,8 +1075,8 @@
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param bool $raw_output
-     * @return string
+     * @param optional Boolean $raw_output
+     * @return String
      * @access public
      */
     function getServerKeyPublicModulus($raw_output = false)
@@ -1509,8 +1090,8 @@
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param bool $raw_output
-     * @return string
+     * @param optional Boolean $raw_output
+     * @return String
      * @access public
      */
     function getHostKeyPublicExponent($raw_output = false)
@@ -1524,8 +1105,8 @@
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param bool $raw_output
-     * @return string
+     * @param optional Boolean $raw_output
+     * @return String
      * @access public
      */
     function getHostKeyPublicModulus($raw_output = false)
@@ -1538,10 +1119,10 @@
      *
      * Just because a cipher is supported by an SSH1 server doesn't mean it's supported by this library. If $raw_output
      * is set to true, returns, instead, an array of constants.  ie. instead of array('Triple-DES in CBC mode'), you'll
-     * get array(self::CIPHER_3DES).
+     * get array(NET_SSH1_CIPHER_3DES).
      *
-     * @param bool $raw_output
-     * @return array
+     * @param optional Boolean $raw_output
+     * @return Array
      * @access public
      */
     function getSupportedCiphers($raw_output = false)
@@ -1554,10 +1135,10 @@
      *
      * Just because a cipher is supported by an SSH1 server doesn't mean it's supported by this library. If $raw_output
      * is set to true, returns, instead, an array of constants.  ie. instead of array('password authentication'), you'll
-     * get array(self::AUTH_PASSWORD).
+     * get array(NET_SSH1_AUTH_PASSWORD).
      *
-     * @param bool $raw_output
-     * @return array
+     * @param optional Boolean $raw_output
+     * @return Array
      * @access public
      */
     function getSupportedAuthentications($raw_output = false)
@@ -1568,75 +1149,11 @@
     /**
      * Return the server identification.
      *
-     * @return string
+     * @return String
      * @access public
      */
     function getServerIdentification()
     {
         return rtrim($this->server_identification);
     }
-
-    /**
-     * Logs data packets
-     *
-     * Makes sure that only the last 1MB worth of packets will be logged
-     *
-     * @param string $data
-     * @access private
-     */
-    function _append_log($protocol_flags, $message)
-    {
-        switch (NET_SSH1_LOGGING) {
-            // useful for benchmarks
-            case self::LOG_SIMPLE:
-                $this->protocol_flags_log[] = $protocol_flags;
-                break;
-            // the most useful log for SSH1
-            case self::LOG_COMPLEX:
-                $this->protocol_flags_log[] = $protocol_flags;
-                $this->_string_shift($message);
-                $this->log_size+= strlen($message);
-                $this->message_log[] = $message;
-                while ($this->log_size > self::LOG_MAX_SIZE) {
-                    $this->log_size-= strlen(array_shift($this->message_log));
-                    array_shift($this->protocol_flags_log);
-                }
-                break;
-            // dump the output out realtime; packets may be interspersed with non packets,
-            // passwords won't be filtered out and select other packets may not be correctly
-            // identified
-            case self::LOG_REALTIME:
-                echo "<pre>\r\n" . $this->_format_log(array($message), array($protocol_flags)) . "\r\n</pre>\r\n";
-                @flush();
-                @ob_flush();
-                break;
-            // basically the same thing as self::LOG_REALTIME with the caveat that self::LOG_REALTIME_FILE
-            // needs to be defined and that the resultant log file will be capped out at self::LOG_MAX_SIZE.
-            // the earliest part of the log file is denoted by the first <<< START >>> and is not going to necessarily
-            // at the beginning of the file
-            case self::LOG_REALTIME_FILE:
-                if (!isset($this->realtime_log_file)) {
-                    // PHP doesn't seem to like using constants in fopen()
-                    $filename = self::LOG_REALTIME_FILE;
-                    $fp = fopen($filename, 'w');
-                    $this->realtime_log_file = $fp;
-                }
-                if (!is_resource($this->realtime_log_file)) {
-                    break;
-                }
-                $entry = $this->_format_log(array($message), array($protocol_flags));
-                if ($this->realtime_log_wrap) {
-                    $temp = "<<< START >>>\r\n";
-                    $entry.= $temp;
-                    fseek($this->realtime_log_file, ftell($this->realtime_log_file) - strlen($temp));
-                }
-                $this->realtime_log_size+= strlen($entry);
-                if ($this->realtime_log_size > self::LOG_MAX_SIZE) {
-                    fseek($this->realtime_log_file, 0);
-                    $this->realtime_log_size = strlen($entry);
-                    $this->realtime_log_wrap = true;
-                }
-                fputs($this->realtime_log_file, $entry);
-        }
-    }
 }
